// The initial draft of this test was generated by AI based on a previously written C# test
// every test has been manually adjusted by hand to work with the apiService
// Success/failure conditions have also been manually implemented
// src/services/__tests__/apiService.test.js
import * as apiService from '../apiService';
import jest from 'jest-mock';
// Test credentials
const testProfileDataList = [
        {
            birthDate: '2000-01-01T00:00:00',
            region: 'Test Region',
            profilePicture: '',
            description: 'Test description'
        },
        {
            birthDate: '1995-05-15T00:00:00',
            region: 'Another Region',
            profilePicture: '',
            description: 'Another test user profile description'
        }
    ];
const testUserDataList = [
    {
        email: 'user@example.com',
        username: 'TestUser',
        password: 'TestPassword123!',
    },
    {
        email: 'user1@example.com',
        username: 'TestUser1',
        password: 'TestPassword123!',
    }
];
const testGroupData = {
    title: `Test Group ${Date.now()}`,
    isVisible: true,
    ageRange: "0 - 99",
    maxMembers: 10,
    description: 'Integration test group',
    tags: ["D&D"]
};
let authToken = null;
let userId = null;
let createdGroupId = null;
// Add this at the top of your test file
const localStorageMock = (() => {
    let store = {};
    return {
        getItem: jest.fn(key => store[key] || null),
        setItem: jest.fn((key, value) => {
            store[key] = value.toString();
        }),
        removeItem: jest.fn(key => {
            delete store[key];
        }),
        clear: jest.fn(() => {
            store = {};
        })
    };
})();
global.localStorage = localStorageMock;

// Skip tests flag - set to true if API is unreachable
let skipTests = false;

// Check API connectivity before tests
beforeAll(async () => {
    try {
        const backEndAddress = apiService.API_BASE.replace(/\/api$/, '');
        const healthCheckUrl = `${backEndAddress}/healthz`;
        const response = await fetch(healthCheckUrl);
        console.log(`Checking endpoint health at: ${healthCheckUrl}`);
        let responseText = await response.text();
        console.log(`Response status: ${responseText}`);
        if (!(responseText === 'Healthy')) {
            console.warn('API is not reachable. Skipping integration tests.');
            skipTests = true;
        }
    } catch (error) {
        console.warn(`Failed to connect to API: ${error.message}`);
        skipTests = true;
        throw new Error(`API is not reachable. Skipping integration tests. ${error.message}`);
    }
}, 10000);

describe('API Service Integration Tests', () => {
    // 1. Registration Test
    test('registers all test users', async () => {
        console.log('registers new users test starting...');
        if (skipTests) return;
        for (let testUser of testUserDataList) {
        try {
            expect(testUser).toBeDefined()
            const result = await apiService.register(testUser.email, testUser.username, testUser.password);
            expect(result).toHaveProperty('message');
            expect(typeof result.message).toBe('string');
            expect(result.message.trim()).toBe("\"User registered successfully!\""); //for some reason the status message is wrapped in quotes??
        } catch (error) {
            if (error.message.includes('already taken')) {
                console.log(`${testUser.username} already exists, continuing...`);
            } else {
                throw error;
            }}
        }
    }, 10000);

    // 2. Login Test
    test('2. logs in user 1 with valid credentials', async () => {
        if (skipTests) return;
        console.log('logs in with valid credentials test starting...');
        let success = await loginUser(0)
        expect(success).toBe(true);
    }, 10000);

    // 3. Update User Profile Test
    test('3. updates test user profiles', async () => {
        if (skipTests)
        {
            console.warn('Skipping update user profile test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping update user profile test - no auth token');
            return;
            }
        console.log('updates a user profile test starting...');
        let i = 0;
        for (let testUserProfile of testProfileDataList) {
            await loginUser(i);
            const result = await apiService.updateUserProfile({
            body: JSON.stringify(testUserProfile)});
            expect(result).toHaveProperty('message');
            expect(result.message).toBe('Profile updated successfully!');
            i++;
            }
    }, 10000);


    // 4. Fetch User Profile Test
    test('4. fetches user profile', async () => {
        if (skipTests)
        {
            console.warn('Skipping update user profile test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping update user profile test - no auth token');
            return;
        }

        console.log('fetches user profile test starting...');
        let loginSuccess = await loginUser(0);
        expect(loginSuccess).toBe(true);
        const result = await apiService.fetchUserProfile();
        compareProfileData(result, testProfileDataList[0]);
    }, 10000);

    // 5. Create Group Test
    test('5. create a new group', async () => {
        if (skipTests)
        {
            console.warn('Skipping new group test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping update new group test - no auth token');
            return;
        }
        console.log('create a new group test starting...');
        const result = await apiService.createGroup(testGroupData);

        expect(result).toHaveProperty('message');
        expect(result.message).toBe('Group created successfully!');
    }, 10000);

    // 6. Fetch Groups Test
    test('6. fetches all groups', async () => {
        if (skipTests)
        {
            console.warn('Skipping fetch groups test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping fetch groups - no auth token');
            return;
        }
        console.log('fetches all groups test starting...');
        const result = await apiService.fetchGroups();
        expect(Array.isArray(result)).toBe(true);


       const foundGroup = result.reduce((max, group) => (group.id > (max?.id || 0)) ? group : max, null);
        expect(foundGroup).toBeDefined();
        compareGroups(foundGroup);
        // Save the group ID for later tests
        expect(foundGroup.id).toBeDefined();
        console.log(`Found ID: ${foundGroup.id}`);
        localStorage.setItem('groupId', foundGroup.id);

    }, 10000);

    // 7. Fetch User Groups Test
    test('7. fetches user groups', async () => {
        if (skipTests)
        {
            console.log('Skipping fetch user groups test');
            return;
        }
        if (!authToken) {
            console.log('Skipping fetch user groups - no auth token');
            return;
        }
        console.log('fetches user groups test starting...');
        const result = await apiService.fetchUserGroups();
        expect(Array.isArray(result)).toBe(true);
        if (createdGroupId) {
            const foundGroup = result.find(group => group.id === createdGroupId);
            expect(foundGroup).toBeDefined();
            compareGroups(foundGroup);
        }
    }, 10000);

    // 8. Fetch Group By ID Test
    test('8. fetches a specific group by ID', async () => {
        createdGroupId = localStorage.getItem('groupId');
        if (skipTests)
        {
            console.warn('Skipping fetch user groups test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping fetch user groups - no auth token');
            return;
        }
        if (!createdGroupId) {
            console.warn('Skipping fetch user groups test - no group ID saved');
            return;
        }
        console.log('fetches group by ID test starting...');
        const result = await apiService.fetchGroupById(createdGroupId);
        expect(result).toBeDefined();
        expect(typeof result).toBe('object');
        expect(result).toHaveProperty('id');
        expect(result.id.toString()).toBe(createdGroupId);
        compareGroups(result);

    }, 10000);

    // 9. Join Group Test
    test('joins a group with user 2', async () => {
        if (skipTests)
        {
            console.log('Skipping joins a group test');
            return;
        }
        if (!authToken) {
            console.log('Skipping joins a group test - no auth token');
            return;
        }
        if (!createdGroupId) {
            console.log('Skipping joins a group test - no group ID saved');
            return;
        }
        await loginUser(1);
        const result = await apiService.joinGroup(createdGroupId);
        expect(result).toBeDefined();
        expect(result).toHaveProperty('message');
        if (result.message == "You are already a member of this group.") {
            console.warn('Already member of this group, skipping current test');
            return;
        }
        expect(result.message).toBe('Group joined successfully!');
    }, 10000);

    // 9. Leave Group Test
    test('leaves a group', async () => {
        if (skipTests)
        {
            console.warn('Skipping update fetch user groups test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping update fetch user groups test - no auth token');
            return;
        }
        if (!createdGroupId) {
            console.warn('Skipping update fetch user groups test - no group ID saved');
            return;
        }

        const result = await apiService.leaveGroup(createdGroupId);
        expect(result).toBeDefined();
        expect(result).toHaveProperty('message');
        await loginUser(1);
        expect(result.message).toBe("Successfully left the group!");
    }, 10000);

    // 10. Delete Group Test
    test('deletes a group', async () => {
        if (skipTests)
        {
            console.warn('Skipping delete group test');
            return;
        }
        if (!authToken) {
            console.warn('Skipping delete group test - no auth token');
            return;
        }
        if (!createdGroupId) {
            console.warn('Skipping delete group test - no group ID saved');
            return;
        }
        console.log('deletes a group test starting...');
        await loginUser(0);
        const result = await apiService.leaveGroup(createdGroupId);
        expect(result).toBeDefined();
        expect(result).toHaveProperty('message');
        expect(result.message).toBe('Successfully left the group!');
        // Check if the group is deleted
        const groups = await apiService.fetchGroups();
        const foundGroup = groups.find(group => group.id === createdGroupId);
        expect(foundGroup).toBeUndefined();
    }, 10000);


    // 12. Fetch Profile by ID Test
    test('fetches another user profile by ID', async () => {
        let idResult;
        try {
            idResult = await apiService.getUserIdByEmail(testUserDataList[0].email);
            expect(idResult).toBeDefined();
            expect(idResult).toHaveProperty('userId');
        }
        catch (error) {
            console.error('Failed to get user ID by name:', error);
        }
        if (skipTests || !authToken || !idResult) return;
        let userId = idResult.userId;
        // This is getting our own profile by ID for simplicity
        const result = await apiService.fetchProfile(userId);
        compareProfileData(result, testProfileDataList[0]);
    }, 10000);

    // 13-14. Group Management Tests (Conditional)
    // Note: These tests would require specific setup with two accounts
    // and are conditionally implemented

    test('accepts a user into group (conditional test)', async () => {
        if (skipTests || !authToken || !createdGroupId) {
            console.warn('Skipping accept user test - requires special setup');
            return;
        }

        // Only run if there's another userId to test with (would need separate setup)
        const otherUserId = process.env.TEST_OTHER_USER_ID;
        if (!otherUserId) {
            console.warn('Skipping accept/reject user tests - no test user ID provided');
            return;
        }

        try {
            const result = await apiService.AcceptUserIntoGroup(createdGroupId, otherUserId);
            expect(result).toBeDefined();
        } catch (error) {
            // This may fail if user isn't in pending state
            console.warn('Accept user test failed, likely due to test preconditions');
        }
    }, 10000);

    test('rejects a user from group (conditional test)', async () => {
        if (skipTests || !authToken || !createdGroupId) {
            console.log('Skipping reject user test - requires special setup');
            return;
        }

        // Only run if there's another userId to test with (would need separate setup)
        const otherUserId = process.env.TEST_OTHER_USER_ID;
        if (!otherUserId) return;

        try {
            const result = await apiService.RejectUserFromGroup(createdGroupId, otherUserId);
            expect(result).toBeDefined();
        } catch (error) {
            // This may fail if user isn't in pending state
            console.log('Reject user test failed, likely due to test preconditions');
        }
    }, 10000);
});

// TODO Update group endpoint test
// Helper functions to compare objects with defined test data
function compareGroups(foundGroup) {
    expect(foundGroup).toBeDefined();
    expect(foundGroup.title).toBe(testGroupData.title);
    expect(foundGroup.description).toBe(testGroupData.description);
    expect(foundGroup.isVisible).toBe(testGroupData.isVisible);
    expect(foundGroup.ageRange).toBe(testGroupData.ageRange);
    expect(foundGroup.maxMembers).toBe(testGroupData.maxMembers);
    expect(foundGroup.tags).toEqual(testGroupData.tags);
}


function compareProfileData(foundUser, expectedProfileData) {
    expect(foundUser).toBeDefined();
    expect(expectedProfileData).toBeDefined();
    expect(foundUser.region).toBe(expectedProfileData.region);
    expect(foundUser.description).toBe(expectedProfileData.description);
    expect(foundUser.birthDate).toBe(expectedProfileData.birthDate);
}
/*function saveToken(token, id) {
    if (!token || !(id>=0 && id < testUserDataList.length)) {
        expect(token).toBeDefined();
        throw new Error(`Invalid token or ID provided for saving. Token: ${token}, ID: ${id}`);
    }
    localStorage.setItem(`token${id}`, token);
}
function setCurrentUser(id) {
    let newToken = localStorage.getItem(`token${id}`);
    if (!newToken) {
        skipTests = true;
        throw new Error('No token found for ID ' + id);
    }
    localStorage.setItem('token', newToken);
    authToken = newToken;
}*/
async function loginUser(id){
    console.log("Logging in user with: " + testUserDataList[id].email);

    localStorage.removeItem('token');
    const result = await apiService.login(testUserDataList[id].email, testUserDataList[id].password)
    if (!result.token) {
        console.error('No token found in login result');
        console.error(result.message);
        return false;
    }
    let oldToken = localStorage.getItem('token');
    localStorage.setItem('token', result.token);
    authToken = result.token;
    if (oldToken === localStorage.getItem('token')) {
        console.error('Token change was unsuccessful!');
        return false;
    }
    console.log('new token saved');
    return true
}
